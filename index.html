<!DOCTYPE html>
<html>
<head>
  <style>
  body {
    width:  100%;
    height: 100%;
    margin: 0px;
  }
  #top_bar {
    margin: 0px;
  }
  #gen_algorithm {
    overflow-y: auto;
    width: 35%;
    margin: 5px;
    padding: 5px;
    font-family: "menlo", sans-serif;
    float: right;
    z-index: -2;
  }
  #code {
    color: #ffffff7a;
    font-size: 15px;
  }
  #code span {
    color: #ffffff4a;
    font-size: 12px;
  }
  #title {
    font-family: "menlo", sans-serif;
    font-size: 40px;
    color: cyan;
    float: left;
  }
  #version {
    height: 40px;
    font-family: "verdana", sans-serif;
    font-size: 14px;
    color: cyan;
    line-height: 65px;
    margin-left: 5px;
    float: left;
  }
  #subtitle {
    font-family: "menlo", sans-serif;
    font-size: 30px;
    color: #777777;
    margin-left: 15px;
    line-height: 60px;
    float: left;
  }
  canvas {
    position: absolute;
    z-index: -1;
  }
  </style>
  <title>pd3v sounding code</title>
  <meta charset="UTF-8">
</head>
<body>
  <script type="text/javascript" src="midiout.js"></script>
  <script type="text/javascript" src="synth.js"></script>
  <script type="text/javascript" src="generator.js"></script>
  <script type="text/javascript" src="sequencer.js"></script>
  <script type="text/javascript" src="helpers.js"></script>
  <canvas id="colorCanvas"></canvas>
  <div id="top_bar">
    <div id="title">fluX</div>
    <div id="version">0.0.1</div>
    <div id="subtitle">sounding</div>
  </div>
  <div id="gen_algorithm">
    <div id="code">gen::</div>
  </div>
</body>
<script>
// Page layout
var canvas = document.getElementById("colorCanvas");
var ctx = canvas.getContext("2d");
ctx.canvas.width  = window.innerWidth;
ctx.canvas.height = window.innerHeight;

var AudioContext = window.AudioContext || window.webkitAudioContext;
var ac = new AudioContext();

var scope = ac.createAnalyser();
var bufferLength = scope.frequencyBinCount;
var dataArray = new Uint8Array(bufferLength);
var fps = 20;

scope.fftSize = 2048;
scope.getByteTimeDomainData(dataArray);

var audio = document.querySelector('audio');

if (navigator.mediaDevices) {
    navigator.mediaDevices.getUserMedia ({audio: true, video: false})
    .then(function(stream) {
        var source = ac.createMediaStreamSource(stream);
        source.connect(scope);
    })
    .catch(function(err) {
        console.log(err);
    });
} else {
   console.log('getUserMedia not supported on your browser!');
}

const CMinorScale = {c:0, d:2, ef:3, f:5, g:7, af:8, bb:10};
const scaleLength = Object.values(CMinorScale).length;

// function composition is using Markov Chains
const composition = scale => {
  let composition = [];
  let phrasings = {};

	for (let i = 0; i < 20; i++){
    composition.push(round(rand(0,Object.keys(scale).length-1)));
	}

  for (let j = 0; j < composition.length-1; j++) {
    if (!phrasings[composition[j]]) {
      phrasings[composition[j]]=[];
    }
    phrasings[composition[j]].push(composition[j+1]);
  }
  return {phrasings, scale};
}

let timeDelta = performance.now();
let compositionObj;
const f = _ => {
  //let genITime = performance.now();
  let ac = 0;
  let phrasing;
  let note;
  let noteIndex;

  // console.log(performance.now()-timeDelta, Sequencer.counter);
  // timeDelta = performance.now();

  // Every 25 notes generate new phrasings
  // if (counter()%25 == 0) {
  if (counter()%2 == 0) {
      console.log('New phrasings'+counter());
      compositionObj = composition(CMinorScale);
  }

  phrasing = compositionObj.phrasings[(Object.keys(compositionObj.phrasings))[countTo(Object.keys(compositionObj.phrasings).length-1)]];
  noteIndex = round(rand(0,phrasing.length-1));
  console.log(phrasing);
  // for (let i=0; i<10000000; i++){
  //   ac += i;
  // }
  const du = round((2**(phrasing.length)))
  const n = phrasing[noteIndex];
  const v = 127*(1-((noteIndex+1)/(phrasing.length))*0.5);
  const d = du;//du >= 32 ? Math.trunc(rand(1,2))*3 : du;
  const o = Math.trunc(scaleTo(0,5,3,5,round(phrasing.reduce((accum, value)=>{
    accum += value;
    return accum;
  })/phrasing.length)))

  // console.log('genFunc processing time:'+(performance.now()-genITime), Sequencer.counter);
  // console.log('phrasing.length:'+phrasing.length, 'counter >>>'+Sequencer.counter);

  return {
    note:n, // randoms note from phrasing
    vel:v, // the smaller the phrasing higher the note's velocity
    dur:d, // the bigger the phrasing shorter the note's duration
    oct:o // averages the phrasing content
  }
}

let ga = _ => {
  // let genITime = performance.now();
  // let n = parseInt(7);
  // let v = parseInt(120);
  // let d = parseInt(4);
  // let o = parseInt(4);
  // if (counter()%10 == 0) {
  //   for (let i=0; i<10000; i++){
  //     ac += i;
  //   }
  // }

  // console.log('genFunc processing time:'+(performance.now()-genITime), Sequencer.counter);
  // console.log('Sequencer.generator.note='+Sequencer.gen.note);

  return {
    note:counter()%7 == 0 ? countTo(3): Math.trunc(scaleTo(0,3,4,6,countTo(3))), // randoms note from phrasing
    vel:100, // the smaller the phrasing higher the note's velocity
    dur:16, //2**(round(Math.random()*5)), // the bigger the phrasing shorter the note's duration
    oct:4 // averages the phrasing content
  }

}

let blah = function(e) {
  return {
    note:counter()%scaleLength, //round(rand(0, scaleLength-1)),
    vel:100, // the smaller the phrasing higher the note's velocity
    dur:8,//counter()%2 == 0 ? 1 : 8,//2**(round(Math.random()*5)), // the bigger the phrasing shorter the note's duration
    oct:counter()%2 == 0 ? 4 : 6//3//round(rand(3,4)) // averages the phrasing content
  }
}

Sequencer.audioContext = ac; // fix
Sequencer.generator(CMinorScale, blah).synth('Synth',{a:0,d:0,r:0}).start(100);
// Sequencer.generator(CMinorScale, blah).midiOut('midi port1').start(160);

document.getElementById("code").innerHTML += '<span>'+composition+f+'</span>';

drawWave();

function drawWave() {
  var sliceWidth = ctx.canvas.width * 1.1 / bufferLength;
  var x = 0;

  scope.getByteTimeDomainData(dataArray);

  ctx.lineWidth = 0.5;
  ctx.strokeStyle = '#999999';
  ctx.stroke();

  setTimeout(function() {
       requestAnimationFrame(drawWave);

       ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
       ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
       ctx.beginPath();

       for(var i = 0; i < bufferLength; i++) {
         var v = dataArray[i]/128.0;
         var y = v*ctx.canvas.height/2;

         if(i === 0) {
           ctx.moveTo(x, y);
         } else {
           ctx.lineTo(x, y);
         }
         x += sliceWidth;
       }
   }, 1000/fps);

  ctx.lineTo(ctx.canvas.width, ctx.canvas.height);
  ctx.stroke();
};
</script>
</html>
